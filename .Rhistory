test_y <- y[foldid == i]
cv_models <- groupMultLambda(x = train_x, y = train_y,
groups = groups, tau = tau, lambda = lambda,
intercept = intercept,penalty=penalty,alg=alg,penGroups=penGroups, ...)
if (cvFunc == "check") {
cv_results <- cbind(cv_results, sapply(cv_models,
model_eval, test_x, test_y, tau = tau))
}
else {
cv_results <- cbind(cv_results, sapply(cv_models,
model_eval, test_x, test_y, func = cvFunc))
}
}
cv_results <- apply(cv_results, 1, mean)
}
if (criteria == "BIC") {
cv_results <- sapply(models, qbic)
}
if (criteria == "PBIC") {
cv_results <- sapply(models, qbic, largeP = TRUE)
}
lambda.min <- lambda[which.min(cv_results)]
return_val <- NULL
#return_val$models <- models
return_val$beta <- model_coefs
return_val$residuals <- model_resids
return_val$rho <- model_rhos
return_val$cv <- data.frame(lambda = lambda, cve = cv_results)
colnames(return_val$cv)[2] <- criteria
return_val$lambda.min <- lambda.min
return_val$penalty <- penalty
return_val$intercept <- intercept
return_val$groups <- groups
class(return_val) <- c("cv.rq.group.pen", "cv.rq.pen")
}
return_val
}
rq.group.fit <- function (x, y, groups, tau = 0.5, lambda, intercept = TRUE,
penalty = "SCAD", alg="QICD", a=3.7,penGroups=NULL, ...)
{
### Some cleaning/checking before getting to the algorithms
p <- ncol(x)
n <- nrow(x)
#if(is.null(penGroups) & max(penGroups) > max(groups)){ stop("penalize groups not coefficients")}
if (!penalty %in% c("LASSO", "SCAD", "MCP")) {
stop("Penalty must be LASSO, SCAD or MCP")
}
if(penalty=="LASSO"){
warning("Group penalties use the L1 norm and the Lasso group penalty is the same as the standard Lasso penalty and therefore does not account for group structure. The group lasso method is only implemented because it is needed for the SCAD and MCP algorithms. Otherwise it should be avoided. ")
}
if(is.null(dim(x))){ stop("x must be matrix with at least 1 column") }
if(length(groups)!=ncol(x)){
stop("length(groups) must be equal to ncol(x)")
}
if( lambda <= 0 ){ stop("lambda must be positive")}
if(penalty=="LASSO"){
pen_func <- lasso
}
if(penalty=="SCAD"){
pen_func <- scad
}
if(penalty=="MCP"){
pen_func <- mcp
}
if (alg == "QICD") {
### QICD Algorithm ###
if( length(lambda) != 1 )
stop( "QICD Algorithm only allows 1 lambda value")
coefs <- QICD.group(y, x, groups, tau, lambda, intercept, penalty,a=a, ...)
### Add extra information to QICD output
coefnames <- paste("x",1:p, sep="") ### Coefficient names
if(intercept)
coefnames <- c("(Intercept)", coefnames)
names(coefs) <- coefnames
if( intercept ){ ### Residuals
residuals <- c( y - x%*%(coefs[-1]) - coefs[1] )
pen_vars <- coefs[-1]
} else {
residuals <- c( y - x%*%coefs )
pen_vars <- coefs
}
if(penalty=="LASSO"){
pen_val <- sum(pen_func(tapply(abs(pen_vars),groups,sum),lambda=lambda))
} else{
pen_val <- sum(pen_func(tapply(abs(pen_vars),groups,sum),lambda=lambda,a=a))
}
rho <- sum( check(residuals) ) # rho (similiar to quantreg)
#1/n*sum( check(residuals) ) ### rho
PenRho <- rho+pen_val
return_val <- list( coefficients=coefs, PenRho=PenRho, residuals=residuals, rho=rho, tau=tau, n=n, intercept=intercept, penalty=penalty)
class(return_val) <- c("rq.group.pen", "rq.pen")
######################
} else {
group_num <- length(unique(groups))
if (length(lambda) == 1) {
lambda <- rep(lambda, group_num)
}
if (length(lambda) != group_num) {
stop("lambdas do not match with group number")
}
if (sum(groups == 0) > 0) {
stop("0 cannot be used as a group")
}
if (dim(x)[2] != length(groups)) {
stop("length of groups must be equal to number of columns in x")
}
if (penalty == "LASSO") {
new_lambda <- NULL
group_count <- xtabs(~groups)
for (g in 1:group_num) {
new_lambda <- c(new_lambda, rep(lambda[g], each = group_count[g]))
}
if(is.null(penGroups)==FALSE){
new_lambda[-which(groups %in% penGroups)] <- 0
}
return_val <- rq.lasso.fit(x, y, tau, new_lambda,
intercept = intercept, ...)
class(return_val) <- c("rq.group.pen", "rq.pen",
"rqLASSO")
}
else {
return_val <- rq.group.lin.prog(x,y,groups,tau,lambda,intercept=intercept,penalty=penalty,penGroups=penGroups,a=a,...)
class(return_val) <- c("rq.group.pen", "rq.pen")
}
}
return_val
}
plot.cv.rq.group.pen <- function (x,y=NULL,...)
{
plot(x$cv[, 1], x$cv[, 2])
}
qaSIS <- function(x,y,tau=.5,linear=FALSE,...){#n.cores=1,...){
if(linear){
eval_function<- function(x,y,tau){
q1 <- rq(y ~ x, tau)
sum((fitted(q1)-quantile(y,tau))^2)
}
eval_results <- apply(x,2,eval_function,y,tau,...)
} else{
eval_function2 <- function(x,y,tau,...){
b <- bs(x,...)
q1 <- rq(y ~ b, tau)
sum((fitted(q1)-quantile(y,tau))^2)
}
eval_results <- apply(x,2,eval_function2,y,tau,...)
}
#if(n.cores==1){
#} else{
#	p <- dim(x)[2]
#	mc_func <- function(idx,...){ eval_function(x[,idx],y,...)}
#	mc_results <- mclapply(1:p, mc_func, mc.cores=n.cores, ...)
#	eval_results <- do.call(c,mc_results)
#}
order( eval_results, decreasing=TRUE)
}
data("BostonHousing")
# 예제 적용
library(mlbench)
data("BostonHousing")
head(BostonHousing, 5)
X = data.matrix(BostonHousing[, -14])
y = BostonHousing[, 14]
head(y)
head(X)
QICD(y, x, tau = 0.75, 2, 1, intercept = TRUE, penalty = "MCL", initial_beta = NULL, a = 3.7, scalex = TRUE, )
x
X = data.matrix(BostonHousing[, -14])
x
head(x)
head(y)
data("BostonHousing")
head(BostonHousing, 5)
X = data.matrix(BostonHousing[, -14])
y = BostonHousing[, 14]
head(x)
QICD(y, X, tau = 0.75, 2, 1, intercept = TRUE, penalty = "MCL", initial_beta = NULL, a = 3.7, scalex = TRUE, )
#################
### Cleaning up the functions
#################
### This function just checks to make sure that the inputs to the QICD functions are appropriate
# Easier to create this function to include in each QICD function
cleanInputs <- function(y, x, lambda, gamma, initial_beta=NULL, intercept=TRUE,
penalty, a, ...){
if( is(x,"matrix") == FALSE){
stop('x needs to be a matrix')
}
if( any(lambda <= 0)){
stop("lambda must be positive")
}
if( any(gamma <= 0)){
stop("gamma must be positive")
}
if( any(gamma > lambda)){
stop("gamma must be smaller than lambda")
}
# Make sure we use br or fn method ("?rq.fit.br" or "?rq.fit.fnc")
# if( method != "br" & method != "fn"){
#   stop("Incorrect method.  Choose br or fn")
# }
if( nrow(x) != length(y) ){
stop('length of y and rows of x do not match')
}
if( !is.null(initial_beta) & (length(initial_beta) < (ncol(x) + intercept)) ){
stop("initial_beta must contain initial value for intercept (if TRUE) and each coefficient")
}
if( penalty == "SCAD" ){
if( a <= 2 )
stop("a must be > 2 for SCAD penalty")
} else if ( penalty == "MCP" ){
if( a <= 1 )
stop("a must be > 1 for MCP penalty")
} else if ( penalty == "MCL" ){
if( a <= 1 )
stop("a must be > 1 for MCL penalty")
} else {
if( penalty != "LASSO" )
stop("wrong penalty function")
}
return(NULL)
}
QICD(y, X, tau = 0.75, 2, 1, intercept = TRUE, penalty = "MCL", initial_beta = NULL, a = 3.7, scalex = TRUE, )
library(quantreg)
QICD(y, X, tau = 0.75, 2, 1, intercept = TRUE, penalty = "MCL", initial_beta = NULL, a = 3.7, scalex = TRUE, )
# cpp
dyn.load("QCD.cpp")
# cpp
dyn.load("C:\Users\sypar\Desktop\sy_work\QCD.cpp")
# cpp
dyn.load("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
# cpp
dyn.load("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
# cpp
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
# cpp
install.packages("Rcpp")
library(Rcpp)
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
writeLines(strsplit(Sys.getenv("PATH"), ";")[[1L]])
find_rtools()
install.packages("Rtools")
library(Rtools)
install.packages("RcppEigen")
installed.packages("RcppArmadillo")
library(RcppEigen)
library(RcppArmadillo)
installed.packages("RcppArmadillo")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
install.packages("devtools")
sourceCpp("QCD.cpp")
sourceCpp("QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
# 예제 적용
library(mlbench)
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
#include <Rcpp.h>
#include <iostream>
#include <math.h>
#include <R.h>
using namespace std;
//extern "C" __declspec(dllexport)
/*
function beta_iteration for updating the beta.
x is the predictor matrix, y is the reponse viable.
beta1 is the coefficients for updating.
j is the subscript of the excluded column of x
tau is the quantile parameter.
return the vector prebeta for caculating the weighted median
*/
//extern "C"{
//function for iteration to get the optimal solution.
// y is the responses, x is the predictors, beta1 is the parameters, nyrow is the row length
// of y, nxcol is the column length of x, tau is the quantile parameter.
extern "C"{
// void F77_NAME(xssort)(double*, double*, int*, int*);
void xssort_ (double*, double*, int*, int*);
// C WRAPPER FUNCTION FOR xssort SUBROUTINE
void quicksort(double *x, double *w, int *n){
int kflag = 2;
//  CALLING FORTRAN	FUNCTION FROM C
// F77_CALL(xssort)(x, w, n, &kflag);
xssort_ (x, w, n, &kflag);
}
void QCD( double *x, double *beta, double *intval, double *penweight, double *residuals,
int *n, int *p, int *intercept, double *tau, double *eps, int *maxin)
// x is the design matrix (just covariates, no column of ones); n x p matrix (converted to vector)
// beta is the initial (and will be the final) value of coefficients; vector of length p
// intval is the initial (and will be the final) value of the intercept; can be anything if no intercept in model
// penweight is the penalty weight for each coefficient; vector of length p
// residuals is the vector of residuals from current value of betas; vector of length n ( = y - x%*%beta )
// n is the number of observations
// p is the number of coefficients (not including intercept)
// intercept is the intercept indicator, 1 is intercept, 0 is no intercept
// tau is the quantile of interest
// thresh is the convergence threshold
// maxin is maximum number of iterations
{
int iter = 0;                 // Iteration count
int col;                  // Column index (p columns in x and then do intercept last)
int row, rowcol, nonzerox;    // Row index, (row, col) entry of x, keep track of nonzero x entries for each column
double *weight = new double[*n + 1]; // Weight vector
int length_weight;                   // Length of weight vector
double *pre_value_final=new double[*n+1]; // pre_value_final is the vector to save the weighted median vector
// Used for computing weighted median
int count3;
double weight_sum, temp1;
// Keep track whether beta vector has converged
double betavecDiff;
double betaDiff;
double newBeta; // placeholder for new beta
while( (iter < *maxin) ) //number of inside iterations
{
col = 0;
betavecDiff = 0;
while( col < *p ) // This is the loop for the coefficients, do the intercept last
{
temp1=0;  // Used for calculation of weighted median
weight_sum=0;  // sum of the weight vector
row = 0;
nonzerox = -1;
rowcol = (*n)*col;
while( row < *n )  // loop through the entries in x of column number col
{
if( x[rowcol] != 0 )
{
nonzerox++;
pre_value_final[nonzerox] = residuals[row];
if( pre_value_final[nonzerox] > 0 )
weight[nonzerox] = fabs(x[rowcol])*(*tau);
else
weight[nonzerox] = fabs(x[rowcol])*(1 - *tau);
pre_value_final[nonzerox] = ( pre_value_final[nonzerox] + x[rowcol]*beta[col] )/( x[rowcol] );
if ( *tau >= 0.5 )
pre_value_final[nonzerox] =  -( pre_value_final[nonzerox] );
weight_sum += weight[nonzerox];
}
row++;
rowcol++;
}
// Compute the extra pseudo-observation (penalty for the coefficient)
nonzerox++;
pre_value_final[nonzerox] = 0;
weight[nonzerox] = penweight[col];
weight_sum += weight[nonzerox];
// Compute the weighted median
length_weight = nonzerox+1;
quicksort( pre_value_final, weight, &length_weight );
count3 = -1;
temp1 = 0;
weight_sum = weight_sum/2; // Don't need sum anymore, just need sum/2
while( temp1 < weight_sum )
{
count3++;
temp1 = temp1 + weight[count3];
}
// Update the coefficient
newBeta = pre_value_final[count3];
if ( *tau >= 0.5)
newBeta = -newBeta;
betaDiff = beta[col] - newBeta;
betavecDiff = betavecDiff + betaDiff*betaDiff;
beta[col] = newBeta;
// Update the residual vector if newBeta has changed
if( betaDiff != 0 )
{
row = 0;
rowcol = (*n)*col;
while( row < *n )
{
residuals[row] = residuals[row] + x[rowcol]*betaDiff;
row++;
rowcol++;
}
}
col++; // Next coefficient and repeat
}
if( *intercept == 1) // If intercept, update the intercept
{
temp1 = 0;  // Used for calculation of univariate tauth quantile
weight_sum = 0;  // sum of the weight vector (for the intercept, everything has weight of 1)
row = 0;
nonzerox = -1;
while( row < *n )  // loop through the entries in x of column number col
{
nonzerox++;
pre_value_final[nonzerox] = residuals[row] + intval[0];
weight[nonzerox] = 1;
row++;
weight_sum = weight_sum + weight[nonzerox];
}
// Compute the univariate tauth quantile
length_weight = nonzerox+1;
quicksort( pre_value_final, weight, &length_weight );
count3 = -1;
temp1 = 0;
weight_sum = weight_sum*(*tau); // Don't need sum anymore, just need sum*tau
while( temp1 < weight_sum )
{
count3++;
temp1 = temp1 + weight[count3];
}
// Update the coefficient
newBeta = pre_value_final[count3];
betaDiff = intval[0] - newBeta;
betavecDiff = betavecDiff + betaDiff*betaDiff;
intval[0] = newBeta;
// Update the residual vector if newBeta has changed
if( betaDiff != 0 )
{
row = 0;
while( row < *n )
{
residuals[row] = residuals[row] + betaDiff;
row++;
}
}
}
if( sqrt(betavecDiff) < *eps ) // Check for convergence
{
break;
}
iter++; // Next iteration (col resets to 0 at the top)
}
// Final clean up
delete [] pre_value_final;
delete [] weight;
}
void penderiv( double *beta, int *p, double *a, double *lambda, double *gamma, int *pentype)
// beta is the vector of coefficients and will return the value of the derivative of the penalties
// n is the number of observations
// p is the number of coefficients
// a is a parameter for SCAD, MCP and MCL
// lambda is a parameter for SCAD, MCP, MCL and LASSO
// gamma is a parameter for MCL
// pentype is the penalty (0 for SCAD, 1 for MCP, 2 for LASSO, 3 for MCL)
{
int count = 0;
double temp;
while( count < *p )
{
if( *pentype == 0 ) // SCAD
{
if( fabs(beta[count]) < lambda[count] )
temp = *lambda;
else if ( fabs(beta[count]) < (*a)*lambda[count] )
temp = ( (*a)*lambda[count] - fabs(beta[count]) )/( *a - 1.0 );
else
temp = 0;
}
else if( *pentype == 1 ) // MCP
{
if ( fabs(beta[count]) < (*a)*lambda[count] )
temp = fabs( lambda[count] - ( fabs(beta[count])/ *a) );
//old	( lambda[count] - fabs(beta[count]) )/( *a );
else
temp = 0;
}
else if( *pentype == 3 ) // MCL
{
if ( fabs(beta[count]) < (*a)*(lambda[count] - gamma[count]) )
temp = fabs(lambda[count] - (fabs(beta[count])/ *a));
else
temp = gamma[count];
}
else // LASSO
{
temp = lambda[count];
}
beta[count] = temp;
count++;
}
}
}
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
install.packages("devtools")
install.packages("roxygen2")
library(devtools)
library(roxygen2)
setwd("test")
setwd("C:/Users/sypar/Desktop/sy_wor/ktest")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
install.packages("jsonlite", type = "source")
library(Rcpp)
library(RcppEigen)
library(RcppArmadillo)
sourceCpp("C:/Users/sypar/Desktop/sy_work/QCD.cpp")
pwd
setwd()
dir()
####################################################################3
library(Rcpp)
sourceCpp(paste0(getwd(), "/QCD.cpp"))
setwd("C:/Users/sypar/sy_work/R_work")
getwd()
sourceCpp(paste0(getwd(), "/QCD.cpp"))
Rcpp::sourceCpp(paste0(getwd(), "/QCD.cpp"))
writeLines("C:/User/sypar/sy_work/R_work")
Rcpp::sourceCpp(paste0(getwd(), "/QCD.cpp"))
Rcpp::sourceCpp(paste0("/QCD.cpp"))
Rcpp::sourceCpp("/QCD.cpp")
Rcpp::sourceCpp("QCD.cpp")
Rcpp::sourceCpp("C:/User/sypar/sy_work/R_work/QCD.cpp")
Rcpp::sourceCpp("C:/User/sypar/sy_work/R_work/src/QCD.cpp")
getwd()
Rcpp::sourceCpp("C:/User/sypar/sy_work/R_work/src/QCD.cpp")
Rcpp::sourceCpp("C:/Users/sypar/sy_work/R_work/src/QCD.cpp")
